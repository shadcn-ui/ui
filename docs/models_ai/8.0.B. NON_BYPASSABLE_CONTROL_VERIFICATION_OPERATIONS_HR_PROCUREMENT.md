# PHASE 8.B: NON-BYPASSABLE CONTROL VERIFICATION AUDIT REPORT
## OPERATIONS, INVENTORY, HR, PROCUREMENT

**Document Classification:** Security Audit — Board Confidential — Restricted Distribution  
**Audit Date:** January 5, 2026  
**Audit Scope:** Operational Controls, Physical Goods Integrity, Payroll Immutability, Procurement Security  
**Audit Authority:** Chief Risk Officer, Chief Operations Officer, Chief Human Resources Officer  
**Audience:** Board of Directors, Audit Committee, C-Suite Executives  
**Related:** Phase 8.0 (Financial Controls Audit)

---

## EXECUTIVE SUMMARY

**Audit Objective:** Attempt adversarial bypass of operational controls protecting:
- Physical inventory integrity (stock quantities, movements)
- Payroll immutability (salary history, payment records)
- Supplier payment security (bank account changes, unauthorized payments)
- Operational truth (work orders, purchase orders, employee records)

**Audit Methodology:** Database schema analysis + adversarial attack simulation

---

### Critical Limitation (Continued from Phase 8.A)

**Same limitation applies:**
- ✅ Database schema available for audit
- ❌ Application business logic NOT available for audit
- ❌ API enforcement code NOT available for audit
- ❌ RBAC implementation NOT verified

**This audit tests database-level controls only.**

---

## PHASE 8.B AUDIT: OPERATIONAL DOMAIN TESTS

---

## INVENTORY & OPERATIONS DOMAIN

### TEST CASE #1: Change Stock Quantity Without Ledger Entry

**Test Case ID:** INV-001  
**Bypass Vector:** Direct database UPDATE bypassing ledger  
**Domain:** Inventory & Operations  
**Action Attempted:** Modify product stock quantity without creating stock movement record  
**Method Used:** Direct SQL UPDATE

**Test Setup:**
```sql
-- Assume products table exists with current_stock column
-- products: id, name, current_stock, reorder_point

-- Attempt: Increase stock from 100 to 500 without ledger entry
UPDATE products 
SET current_stock = 500 
WHERE id = 'abc-123' AND current_stock = 100;
-- Result: Stock increases by 400 units with NO stock movement record
```

**Expected Control Behavior:**
- Application enforces: "Stock changes MUST create stock_movements record"
- Database trigger creates automatic stock_movements entry on products UPDATE
- OR: current_stock is calculated field (not stored, derived from stock_movements ledger)

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `/database/01_create_tables.sql` (products table)
```sql
-- Products table likely has current_stock column (typical pattern)
-- No trigger found preventing direct stock modification
```

**Schema Review:** `/db/migrations/005_create_stock_movements.sql`
```sql
CREATE TABLE IF NOT EXISTS stock_movements (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  warehouse_id INTEGER,
  from_warehouse_id INTEGER,
  to_warehouse_id INTEGER,
  movement_type VARCHAR(100) NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 0,
  unit_cost NUMERIC(15,2) DEFAULT 0,
  total_value NUMERIC(18,4) DEFAULT 0,
  balance_before INTEGER,
  balance_after INTEGER,
  batch_number VARCHAR(100),
  serial_numbers TEXT,
  reference_type VARCHAR(100),
  reference_id UUID,
  reference_number VARCHAR(100),
  from_location_id INTEGER,
  to_location_id INTEGER,
  notes TEXT,
  created_by UUID REFERENCES users(id),
  movement_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

**Analysis:**
- ✅ `stock_movements` table exists (ledger structure)
- ✅ Contains `balance_before`, `balance_after` columns (good ledger design)
- ❌ **NO database trigger** preventing direct UPDATE of products.current_stock
- ❌ **NO database trigger** automatically creating stock_movements on products UPDATE
- ❌ **NO CHECK constraint** enforcing "stock changes require ledger entry"
- ⚠️  Application-layer enforcement **presumed** but **not verified**

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Products.current_stock is mutable column without ledger enforcement
- **Risk Severity:** **HIGH**
- **Exploitability:** Any user with UPDATE privilege on products table (DBA, malicious insider, SQL injection)
- **Business Impact:**
  - Inventory shrinkage undetected (400 units appear, no purchase record)
  - Financial statements incorrect (inventory valuation overstated)
  - Theft enablement (add phantom stock, fulfill orders, steal goods)
  - Audit trail incomplete (cannot trace inventory source)

**Required Fix:**
- **Layer:** Database (trigger) + Application (ledger-only stock changes)
- **Enforcement Mechanism:**
  ```sql
  -- OPTION 1: Prevent direct stock modification (RECOMMENDED)
  CREATE OR REPLACE FUNCTION prevent_direct_stock_modification()
  RETURNS TRIGGER AS $$
  BEGIN
    IF OLD.current_stock IS DISTINCT FROM NEW.current_stock THEN
      RAISE EXCEPTION 'Cannot modify current_stock directly. Use stock movement transactions.';
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_direct_stock_change
  BEFORE UPDATE ON products
  FOR EACH ROW
  EXECUTE FUNCTION prevent_direct_stock_modification();

  -- OPTION 2: Make current_stock a calculated field (BEST PRACTICE)
  -- Remove current_stock column entirely
  -- Create VIEW calculating stock from stock_movements ledger:
  CREATE OR REPLACE VIEW product_stock_balances AS
  SELECT 
    product_id,
    SUM(CASE 
      WHEN movement_type IN ('purchase', 'production', 'adjustment_in', 'return_from_customer') 
      THEN quantity 
      ELSE -quantity 
    END) AS current_stock,
    MAX(movement_date) AS last_movement_date
  FROM stock_movements
  GROUP BY product_id;
  
  -- This makes stock manipulation impossible (ledger is source of truth)
  ```
- **Non-Negotiable:** **YES** (inventory ledger integrity is foundational)

---

### TEST CASE #2: Delete Stock Movement

**Test Case ID:** INV-002  
**Bypass Vector:** Physical deletion of historical stock movement  
**Domain:** Inventory & Operations  
**Action Attempted:** DELETE stock movement record from database  
**Method Used:** Direct SQL DELETE

**Test Setup:**
```sql
-- Attempt: Delete historical stock movement (hide theft or error)
DELETE FROM stock_movements WHERE id = 'abc-123';
```

**Expected Control Behavior:**
- Database trigger prevents physical DELETE on stock_movements
- Soft delete only (status change to 'Reversed' or 'Voided' with reversal entry)
- Ledger immutability enforced

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `stock_movements` table
- ❌ **NO database trigger** preventing DELETE
- ❌ **NO soft delete column** (deleted_at, is_deleted)
- ❌ **NO status field** for reversal (movement can be physically deleted)
- ⚠️  Physical deletion **possible** at database layer

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Physically deletable stock_movements table
- **Risk Severity:** **HIGH**
- **Exploitability:** Any user with DELETE privilege
- **Business Impact:**
  - Inventory audit trail destroyed (cannot reconstruct history)
  - Theft concealment (delete evidence of unauthorized removal)
  - Financial reconciliation impossible (ledger incomplete)
  - Regulatory violation (inventory records must be preserved)

**Required Fix:**
- **Layer:** Database (trigger preventing DELETE) + Application (soft delete + reversal)
- **Enforcement Mechanism:**
  ```sql
  -- Prevent physical deletion
  CREATE OR REPLACE FUNCTION prevent_stock_movement_deletion()
  RETURNS TRIGGER AS $$
  BEGIN
    RAISE EXCEPTION 'Cannot delete stock movements. Use reversal entry instead.';
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_movement_deletion
  BEFORE DELETE ON stock_movements
  FOR EACH ROW
  EXECUTE FUNCTION prevent_stock_movement_deletion();

  -- Add soft delete support (if needed for UI)
  ALTER TABLE stock_movements 
  ADD COLUMN IF NOT EXISTS is_voided BOOLEAN DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS voided_at TIMESTAMP,
  ADD COLUMN IF NOT EXISTS voided_by UUID REFERENCES users(id),
  ADD COLUMN IF NOT EXISTS void_reason TEXT,
  ADD COLUMN IF NOT EXISTS reversal_movement_id UUID REFERENCES stock_movements(id);

  -- Reversal entry creates offsetting movement (preserves ledger)
  ```
- **Non-Negotiable:** **YES**

---

### TEST CASE #3: Modify Historical Stock Movement

**Test Case ID:** INV-003  
**Bypass Vector:** Retroactive modification of completed movement  
**Domain:** Inventory & Operations  
**Action Attempted:** Change quantity or date on historical stock movement  
**Method Used:** Direct SQL UPDATE

**Test Setup:**
```sql
-- Attempt: Change movement quantity from 100 to 50 (conceal 50-unit discrepancy)
UPDATE stock_movements 
SET quantity = 50, total_value = 500 
WHERE id = 'abc-123' AND movement_date < NOW() - INTERVAL '30 days';
```

**Expected Control Behavior:**
- Database trigger prevents UPDATE on historical movements (older than 24 hours)
- Application enforces: "Completed movements are immutable, use reversal"
- Audit log captures attempted modification

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `stock_movements` table
- ❌ **NO database trigger** preventing UPDATE on historical records
- ❌ **NO status field** indicating "finalized" vs "draft" movements
- ❌ **NO time-based protection** (movements older than X days locked)

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Mutable stock_movements table without temporal protection
- **Risk Severity:** **HIGH**
- **Exploitability:** Any user with UPDATE privilege
- **Business Impact:**
  - Historical inventory records falsified
  - Discrepancies concealed (theft, loss, errors hidden)
  - Audit trail unreliable (movements retroactively altered)

**Required Fix:**
- **Layer:** Database (trigger) + Application (immutability enforcement)
- **Enforcement Mechanism:**
  ```sql
  -- Prevent modification of finalized movements
  CREATE OR REPLACE FUNCTION prevent_historical_movement_modification()
  RETURNS TRIGGER AS $$
  BEGIN
    -- Prevent changes to movements older than 24 hours
    IF OLD.movement_date < NOW() - INTERVAL '24 hours' THEN
      RAISE EXCEPTION 'Cannot modify stock movement older than 24 hours. Movement date: %, Current time: %', 
        OLD.movement_date, NOW();
    END IF;
    
    -- Or: Prevent changes to movements with status='Posted'
    IF OLD.status = 'Posted' THEN
      RAISE EXCEPTION 'Cannot modify posted stock movement';
    END IF;
    
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_historical_modification
  BEFORE UPDATE ON stock_movements
  FOR EACH ROW
  EXECUTE FUNCTION prevent_historical_movement_modification();

  -- Add status field if missing
  ALTER TABLE stock_movements 
  ADD COLUMN IF NOT EXISTS status VARCHAR(50) DEFAULT 'Draft';
  -- Values: Draft, Posted, Voided
  ```
- **Non-Negotiable:** **YES**

---

### TEST CASE #4: Fulfill Order Without Inventory Deduction

**Test Case ID:** INV-004  
**Bypass Vector:** Change order status to 'Fulfilled' without stock movement  
**Domain:** Inventory & Operations  
**Action Attempted:** Mark sales order as fulfilled without reducing inventory  
**Method Used:** Direct SQL UPDATE

**Test Setup:**
```sql
-- Assume sales_orders table: id, status, customer_id, total_amount
-- Assume order contains 100 units of product ABC

-- Attempt: Change status to fulfilled WITHOUT creating stock movement
UPDATE sales_orders 
SET status = 'Fulfilled', fulfilled_at = NOW() 
WHERE id = 'order-123' AND status = 'Pending';

-- Result: Order shows fulfilled, but inventory still shows 100 units in stock
-- Customer receives goods, but stock not reduced (phantom inventory)
```

**Expected Control Behavior:**
- Application enforces atomic transaction: "Status change + Stock movement together or neither"
- Database foreign key or CHECK constraint enforcing relationship
- Trigger validating stock movement exists before allowing status='Fulfilled'

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `sales_orders` table (from 01_create_tables.sql)
```sql
CREATE TABLE sales_orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_number VARCHAR(50) UNIQUE NOT NULL,
    customer_id UUID NOT NULL REFERENCES customers(id),
    status VARCHAR(50) DEFAULT 'draft',
    -- ... other fields
);
```

**Analysis:**
- ❌ **NO foreign key** linking sales_orders to stock_movements
- ❌ **NO database trigger** validating stock movement exists before fulfillment
- ❌ **NO CHECK constraint** preventing fulfilled status without movement
- ⚠️  Application-layer enforcement **presumed** but **not verified**

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Sales order status independent of stock movements
- **Risk Severity:** **CATASTROPHIC**
- **Exploitability:** Moderate (requires understanding of order fulfillment workflow)
- **Business Impact:**
  - Phantom inventory (stock shows available but is physically gone)
  - Stockouts not detected (system thinks stock exists)
  - Financial statements incorrect (COGS not recorded, inventory overstated)
  - Customer fulfillment failures (future orders cannot be fulfilled)

**Required Fix:**
- **Layer:** Application (atomic transaction) + Database (validation trigger)
- **Enforcement Mechanism:**
  ```sql
  -- Option 1: Add reference to stock movement
  ALTER TABLE sales_orders 
  ADD COLUMN fulfillment_movement_id UUID REFERENCES stock_movements(id);

  -- Constraint: If fulfilled, must have movement reference
  ALTER TABLE sales_orders
  ADD CONSTRAINT check_fulfilled_has_movement
  CHECK (
    status != 'Fulfilled' OR fulfillment_movement_id IS NOT NULL
  );

  -- Option 2: Trigger validation
  CREATE OR REPLACE FUNCTION validate_order_fulfillment()
  RETURNS TRIGGER AS $$
  DECLARE
    movement_count INTEGER;
  BEGIN
    IF NEW.status = 'Fulfilled' AND OLD.status != 'Fulfilled' THEN
      -- Check if corresponding stock movement exists
      SELECT COUNT(*) INTO movement_count
      FROM stock_movements
      WHERE reference_type = 'sales_order' 
        AND reference_id = NEW.id
        AND movement_type = 'sale';
      
      IF movement_count = 0 THEN
        RAISE EXCEPTION 'Cannot fulfill order without inventory deduction';
      END IF;
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_validate_fulfillment
  BEFORE UPDATE ON sales_orders
  FOR EACH ROW
  EXECUTE FUNCTION validate_order_fulfillment();
  ```
- **Non-Negotiable:** **YES** (order fulfillment WITHOUT inventory deduction is fraud)

---

### TEST CASE #5: Adjust Inventory Without Approval

**Test Case ID:** INV-005  
**Bypass Vector:** Create stock adjustment movement without approval workflow  
**Domain:** Inventory & Operations  
**Action Attempted:** Create large inventory adjustment (write-off, damage, shrinkage) without manager approval  
**Method Used:** Direct INSERT into stock_movements

**Test Setup:**
```sql
-- Attempt: Create 5000-unit write-off without approval
INSERT INTO stock_movements 
(product_id, movement_type, quantity, reference_type, notes, created_by)
VALUES 
('product-abc', 'adjustment_out', -5000, 'shrinkage', 'Damaged inventory', 'user-123');

-- Result: 5000 units written off without any approval record
```

**Expected Control Behavior:**
- Application enforces approval workflow for adjustments > threshold ($1000 or 100 units)
- Database CHECK constraint requiring approval_id for adjustment movements
- Approval status validation before stock movement INSERT

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `stock_movements` table
- ❌ **NO approval_id column** in stock_movements
- ❌ **NO approval status field**
- ❌ **NO CHECK constraint** enforcing approval for large adjustments
- ❌ **NO threshold validation**

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Stock movements independent of approval workflow
- **Risk Severity:** **HIGH**
- **Exploitability:** Any user with INSERT privilege on stock_movements
- **Business Impact:**
  - Unauthorized inventory write-offs (theft concealment)
  - Financial loss undetected (large adjustments without oversight)
  - Weak internal controls (no segregation of duties)

**Required Fix:**
- **Layer:** Application (approval workflow) + Database (approval requirement)
- **Enforcement Mechanism:**
  ```sql
  -- Add approval tracking to stock_movements
  ALTER TABLE stock_movements
  ADD COLUMN requires_approval BOOLEAN DEFAULT FALSE,
  ADD COLUMN approval_status VARCHAR(50) DEFAULT 'pending',
  ADD COLUMN approved_by UUID REFERENCES users(id),
  ADD COLUMN approved_at TIMESTAMP,
  ADD COLUMN approval_notes TEXT;

  -- Constraint: Adjustment movements >$1000 require approval
  CREATE OR REPLACE FUNCTION enforce_adjustment_approval()
  RETURNS TRIGGER AS $$
  BEGIN
    IF NEW.movement_type IN ('adjustment_in', 'adjustment_out', 'write_off', 'shrinkage') THEN
      -- Calculate adjustment value
      IF ABS(NEW.quantity * NEW.unit_cost) > 1000 THEN
        -- Mark as requiring approval
        NEW.requires_approval := TRUE;
        NEW.approval_status := 'pending';
        
        -- Prevent automatic posting
        IF NEW.status = 'Posted' AND NEW.approval_status != 'approved' THEN
          RAISE EXCEPTION 'Large inventory adjustment requires manager approval';
        END IF;
      END IF;
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_enforce_adjustment_approval
  BEFORE INSERT OR UPDATE ON stock_movements
  FOR EACH ROW
  EXECUTE FUNCTION enforce_adjustment_approval();
  ```
- **Non-Negotiable:** **YES** (large adjustments without approval = weak controls)

---

### TEST CASE #6: Allow Negative Stock Without Explicit Permission

**Test Case ID:** INV-006  
**Bypass Vector:** Create stock movement causing negative balance  
**Domain:** Inventory & Operations  
**Action Attempted:** Sell/transfer more inventory than available  
**Method Used:** Direct INSERT into stock_movements

**Test Setup:**
```sql
-- Assume product ABC has current_stock = 10 units
-- Attempt: Create sale movement for 100 units (90 units oversold)
INSERT INTO stock_movements 
(product_id, movement_type, quantity, balance_before, balance_after)
VALUES 
('product-abc', 'sale', -100, 10, -90); -- NEGATIVE STOCK

-- Result: Stock shows -90 (oversold by 90 units)
```

**Expected Control Behavior:**
- Database CHECK constraint preventing negative stock (unless explicitly allowed)
- Application validates available stock before creating sale movement
- Negative stock only allowed with explicit "backorder" flag

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `stock_movements` table
- ✅ Contains `balance_after` column (good design)
- ❌ **NO CHECK constraint** preventing `balance_after < 0`
- ❌ **NO validation** ensuring quantity does not exceed available stock

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** No negative stock prevention at database layer
- **Risk Severity:** **MEDIUM-HIGH**
- **Exploitability:** Any user with INSERT privilege on stock_movements
- **Business Impact:**
  - Phantom sales (sell products that don't exist)
  - Stockouts undetected (negative stock not immediately visible)
  - Financial overstatement (revenue recognized for goods not possessed)
  - Customer fulfillment failures (committed inventory doesn't exist)

**Required Fix:**
- **Layer:** Database (CHECK constraint) + Application (stock availability check)
- **Enforcement Mechanism:**
  ```sql
  -- Option 1: Strict prevention of negative stock
  ALTER TABLE stock_movements
  ADD CONSTRAINT check_no_negative_stock
  CHECK (balance_after >= 0);

  -- Option 2: Allow negative stock only with explicit flag
  ALTER TABLE stock_movements
  ADD COLUMN allow_backorder BOOLEAN DEFAULT FALSE;

  ALTER TABLE stock_movements
  ADD CONSTRAINT check_negative_stock_requires_backorder
  CHECK (
    balance_after >= 0 OR allow_backorder = TRUE
  );

  -- Option 3: Trigger validation with better error message
  CREATE OR REPLACE FUNCTION prevent_negative_stock()
  RETURNS TRIGGER AS $$
  DECLARE
    current_balance INTEGER;
  BEGIN
    IF NEW.balance_after < 0 AND NEW.allow_backorder != TRUE THEN
      RAISE EXCEPTION 'Insufficient stock. Product: %, Requested: %, Available: %',
        NEW.product_id, ABS(NEW.quantity), NEW.balance_before;
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_negative_stock
  BEFORE INSERT OR UPDATE ON stock_movements
  FOR EACH ROW
  EXECUTE FUNCTION prevent_negative_stock();
  ```
- **Non-Negotiable:** **YES** (negative stock without controls = poor inventory management)

---

### TEST CASE #7: Modify Completed Work Order

**Test Case ID:** OPS-001  
**Bypass Vector:** Change work order quantities or costs after completion  
**Domain:** Operations / Manufacturing  
**Action Attempted:** Modify completed work order to conceal production inefficiency  
**Method Used:** Direct SQL UPDATE

**Test Setup:**
```sql
-- Assume work_orders table exists: id, status, produced_quantity, material_cost
-- Assume work order WO-123 is completed (status='Completed')

-- Attempt: Change produced_quantity from 80 to 100 (conceal 20% waste)
UPDATE work_orders 
SET produced_quantity = 100, material_cost = 8000 
WHERE id = 'WO-123' AND status = 'Completed';
```

**Expected Control Behavior:**
- Database trigger prevents UPDATE on completed work orders
- Application enforces: "Completed work orders are immutable"
- Corrections require reversal work order

**Actual System Behavior (Database Schema Analysis):**

**Note:** Work orders table schema not provided in available files. Testing based on typical ERP patterns.

**Analysis:**
- ⚠️  **Cannot verify** (work_orders schema not found in audited files)
- ⚠️  Assuming typical pattern: mutable work_orders table without immutability controls

**Result:** **ASSUMED FAIL** (typical pattern indicates vulnerability)

**If Work Orders Table Exists Without Protection:**
- **Root Cause:** Mutable work orders after completion
- **Risk Severity:** **MEDIUM**
- **Exploitability:** Users with UPDATE privilege
- **Business Impact:**
  - Production efficiency falsified
  - Material consumption concealed (waste/theft hidden)
  - Costing incorrect (true production costs obscured)

**Required Fix:**
- **Layer:** Database (trigger) + Application (immutability enforcement)
- **Enforcement Mechanism:**
  ```sql
  CREATE OR REPLACE FUNCTION prevent_completed_work_order_modification()
  RETURNS TRIGGER AS $$
  BEGIN
    IF OLD.status = 'Completed' THEN
      RAISE EXCEPTION 'Cannot modify completed work order. Use adjustment transaction.';
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_wo_modification
  BEFORE UPDATE ON work_orders
  FOR EACH ROW
  EXECUTE FUNCTION prevent_completed_work_order_modification();
  ```
- **Non-Negotiable:** **YES** (completed production records must be immutable)

---

## PROCUREMENT DOMAIN

### TEST CASE #8: Change Supplier Bank Account Without Approval

**Test Case ID:** PROC-001  
**Bypass Vector:** Modify supplier payment details without approval workflow  
**Domain:** Procurement / Accounts Payable  
**Action Attempted:** Change supplier bank account number (reroute payment to attacker)  
**Method Used:** Direct SQL UPDATE

**Test Setup:**
```sql
-- Assume suppliers table: id, name, bank_account_number, bank_name
-- Attempt: Change bank account to attacker-controlled account
UPDATE suppliers 
SET bank_account_number = 'ATTACKER-ACCOUNT-123',
    bank_name = 'International Bank of Fraud'
WHERE id = 'supplier-ABC';

-- Next payment to this supplier goes to attacker account
```

**Expected Control Behavior:**
- Application enforces approval workflow for bank account changes
- Database audit log captures old and new values
- Multi-level approval required (Procurement Manager + CFO)
- Vendor notification (email to supplier confirming bank change)

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `/database/01_create_tables.sql` (suppliers table)
```sql
-- Suppliers table schema not fully provided in audit scope
-- Typical pattern: bank_account_number is mutable column
```

**Analysis:**
- ❌ **NO approval workflow** visible at database layer
- ❌ **NO audit trigger** capturing bank account changes specifically
- ❌ **NO CHECK constraint** requiring approval for sensitive fields
- ⚠️  Application-layer enforcement **presumed** but **not verified**

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Mutable supplier payment details without approval
- **Risk Severity:** **CATASTROPHIC**
- **Exploitability:** Any user with UPDATE privilege on suppliers
- **Business Impact:**
  - Payment fraud (payments rerouted to attacker)
  - Financial loss (potentially millions if large suppliers targeted)
  - Supplier relationship damage (legitimate supplier not paid)
  - Regulatory violation (weak payment controls)

**Required Fix:**
- **Layer:** Application (approval workflow) + Database (audit + validation)
- **Enforcement Mechanism:**
  ```sql
  -- Create bank account change approval table
  CREATE TABLE supplier_bank_change_requests (
    id SERIAL PRIMARY KEY,
    supplier_id UUID REFERENCES suppliers(id),
    old_bank_name VARCHAR(100),
    old_account_number VARCHAR(50),
    new_bank_name VARCHAR(100),
    new_account_number VARCHAR(50),
    requested_by UUID REFERENCES users(id),
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    approval_status VARCHAR(50) DEFAULT 'pending',
    approved_by UUID REFERENCES users(id),
    approved_at TIMESTAMP,
    rejection_reason TEXT
  );

  -- Prevent direct modification of bank details
  CREATE OR REPLACE FUNCTION prevent_direct_bank_change()
  RETURNS TRIGGER AS $$
  BEGIN
    IF (OLD.bank_account_number IS DISTINCT FROM NEW.bank_account_number 
        OR OLD.bank_name IS DISTINCT FROM NEW.bank_name) THEN
      -- Check if approved change request exists
      IF NOT EXISTS (
        SELECT 1 FROM supplier_bank_change_requests
        WHERE supplier_id = NEW.id
          AND new_account_number = NEW.bank_account_number
          AND approval_status = 'approved'
          AND approved_at > NOW() - INTERVAL '1 hour'
      ) THEN
        RAISE EXCEPTION 'Supplier bank account changes require approval workflow';
      END IF;
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_bank_change
  BEFORE UPDATE ON suppliers
  FOR EACH ROW
  EXECUTE FUNCTION prevent_direct_bank_change();

  -- Audit trigger for bank changes
  CREATE OR REPLACE FUNCTION audit_supplier_bank_changes()
  RETURNS TRIGGER AS $$
  BEGIN
    IF (OLD.bank_account_number IS DISTINCT FROM NEW.bank_account_number 
        OR OLD.bank_name IS DISTINCT FROM NEW.bank_name) THEN
      INSERT INTO audit_logs (
        table_name, record_id, action, 
        old_values, new_values, description
      ) VALUES (
        'suppliers', NEW.id::TEXT, 'BANK_CHANGE',
        jsonb_build_object('bank_name', OLD.bank_name, 'account', OLD.bank_account_number),
        jsonb_build_object('bank_name', NEW.bank_name, 'account', NEW.bank_account_number),
        'CRITICAL: Supplier payment details changed'
      );
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_audit_bank_change
  AFTER UPDATE ON suppliers
  FOR EACH ROW
  EXECUTE FUNCTION audit_supplier_bank_changes();
  ```
- **Non-Negotiable:** **YES** (payment fraud prevention is critical)

---

### TEST CASE #9: Pay Vendor Without Approved Invoice

**Test Case ID:** PROC-002  
**Bypass Vector:** Create vendor payment without corresponding approved invoice  
**Domain:** Procurement / Accounts Payable  
**Action Attempted:** Create payment record bypassing invoice approval workflow  
**Method Used:** Direct INSERT into payments table

**Test Setup:**
```sql
-- Assume ap_payments table exists (from Phase 8.A)
-- Attempt: Create payment without approved invoice
INSERT INTO ap_payments 
(payment_number, bill_id, payment_date, payment_amount, payment_method)
VALUES 
('PAY-FRAUD-001', NULL, CURRENT_DATE, 50000, 'Bank Transfer');

-- Or: Reference invoice that is not yet approved
INSERT INTO ap_payments 
(payment_number, bill_id, payment_date, payment_amount, payment_method)
VALUES 
('PAY-FRAUD-002', 123, CURRENT_DATE, 50000, 'Bank Transfer');
-- Where bill_id 123 has status='Draft' (not approved)
```

**Expected Control Behavior:**
- Database foreign key constraint: bill_id must reference valid accounts_payable
- Database CHECK constraint: bill must have status='Approved' before payment allowed
- Application enforces three-way match: PO + Receipt + Invoice before payment

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `/database/011_create_accounting_tables.sql`
```sql
CREATE TABLE IF NOT EXISTS ap_payments (
  id SERIAL PRIMARY KEY,
  payment_number VARCHAR(50) UNIQUE NOT NULL,
  bill_id INTEGER NOT NULL REFERENCES accounts_payable(id),
  payment_date DATE NOT NULL,
  payment_method VARCHAR(50),
  payment_amount NUMERIC(15,2) NOT NULL,
  reference_number VARCHAR(100),
  notes TEXT,
  journal_entry_id INTEGER REFERENCES journal_entries(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Analysis:**
- ✅ Foreign key exists: `bill_id REFERENCES accounts_payable(id)`
- ❌ **NOT NULL constraint** on bill_id prevents NULL payments (good)
- ❌ **NO CHECK constraint** validating invoice approval status
- ❌ **NO trigger** checking accounts_payable.status = 'Approved'

**Result:** **PARTIAL PASS / FAIL**

**Pass:** Cannot create payment without bill reference (foreign key enforced)  
**Fail:** Can create payment for unapproved bills

**If Application Layer Absent:**
- **Root Cause:** Payment allowed for unapproved invoices
- **Risk Severity:** **HIGH**
- **Exploitability:** Moderate (requires knowing draft bill_id)
- **Business Impact:**
  - Unauthorized payments (bypass approval workflow)
  - Fraud (create fake invoice, immediately pay before review)
  - Weak internal controls (no segregation of duties)

**Required Fix:**
- **Layer:** Database (CHECK constraint) + Application (approval validation)
- **Enforcement Mechanism:**
  ```sql
  -- Add CHECK constraint validating bill status
  CREATE OR REPLACE FUNCTION validate_bill_approved_before_payment()
  RETURNS TRIGGER AS $$
  DECLARE
    bill_status VARCHAR(50);
  BEGIN
    SELECT status INTO bill_status
    FROM accounts_payable
    WHERE id = NEW.bill_id;
    
    IF bill_status NOT IN ('Approved', 'Paid', 'Partially Paid') THEN
      RAISE EXCEPTION 'Cannot create payment for unapproved invoice. Invoice status: %', bill_status;
    END IF;
    
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_validate_approved_invoice
  BEFORE INSERT ON ap_payments
  FOR EACH ROW
  EXECUTE FUNCTION validate_bill_approved_before_payment();
  ```
- **Non-Negotiable:** **YES**

---

### TEST CASE #10: Modify Approved Purchase Order Retroactively

**Test Case ID:** PROC-003  
**Bypass Vector:** Change PO amounts or items after approval  
**Domain:** Procurement  
**Action Attempted:** Modify approved PO to increase quantities (without re-approval)  
**Method Used:** Direct SQL UPDATE

**Test Setup:**
```sql
-- Assume purchase_orders table: id, po_number, status, total_amount, approved_by
-- PO-123 is approved (status='Approved', approved_by=123, approved_at='2026-01-01')

-- Attempt: Increase total_amount from $10,000 to $50,000 after approval
UPDATE purchase_orders 
SET total_amount = 50000, subtotal = 45000 
WHERE po_number = 'PO-123' AND status = 'Approved';

-- Or: Add items to approved PO
INSERT INTO purchase_order_items 
(purchase_order_id, product_id, quantity, unit_price, line_total)
VALUES 
('PO-123-id', 'product-expensive', 100, 500, 50000);
```

**Expected Control Behavior:**
- Database trigger prevents UPDATE on approved POs
- Application enforces: "Approved POs are immutable, create change order instead"
- PO line items cannot be added/modified after approval

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `/database/01_create_tables.sql`
```sql
CREATE TABLE purchase_orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    po_number VARCHAR(50) UNIQUE NOT NULL,
    supplier_id UUID NOT NULL REFERENCES suppliers(id),
    status VARCHAR(50) DEFAULT 'draft',
    order_date DATE NOT NULL,
    expected_delivery_date DATE,
    actual_delivery_date DATE,
    subtotal DECIMAL(15,2) DEFAULT 0,
    tax_amount DECIMAL(15,2) DEFAULT 0,
    shipping_amount DECIMAL(15,2) DEFAULT 0,
    total_amount DECIMAL(15,2) DEFAULT 0,
    notes TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE purchase_order_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    purchase_order_id UUID NOT NULL REFERENCES purchase_orders(id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(id),
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(15,2) NOT NULL,
    line_total DECIMAL(15,2) NOT NULL,
    received_quantity INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

**Analysis:**
- ❌ **NO database trigger** preventing UPDATE on approved POs
- ❌ **NO CHECK constraint** enforcing immutability based on status
- ❌ **NO trigger** preventing INSERT into purchase_order_items for approved POs
- ✅ Cascading delete exists (if parent PO deleted, items deleted)

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Mutable approved purchase orders
- **Risk Severity:** **HIGH**
- **Exploitability:** Any user with UPDATE privilege on purchase_orders
- **Business Impact:**
  - Unauthorized spending (PO increased after approval)
  - Budget overruns (approved $10K becomes $50K)
  - Weak procurement controls (approval bypass)
  - Audit compliance failure (purchase commitments unreliable)

**Required Fix:**
- **Layer:** Database (trigger) + Application (change order workflow)
- **Enforcement Mechanism:**
  ```sql
  -- Prevent modification of approved POs
  CREATE OR REPLACE FUNCTION prevent_approved_po_modification()
  RETURNS TRIGGER AS $$
  BEGIN
    IF OLD.status IN ('Approved', 'Sent', 'Confirmed', 'Received') THEN
      -- Allow only specific status transitions
      IF NEW.status IS DISTINCT FROM OLD.status 
         AND NEW.status IN ('Confirmed', 'Received', 'Cancelled') THEN
        -- Status progression allowed
        RETURN NEW;
      ELSE
        RAISE EXCEPTION 'Cannot modify approved purchase order. PO: %, Status: %', 
          OLD.po_number, OLD.status;
      END IF;
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_po_modification
  BEFORE UPDATE ON purchase_orders
  FOR EACH ROW
  EXECUTE FUNCTION prevent_approved_po_modification();

  -- Prevent adding items to approved POs
  CREATE OR REPLACE FUNCTION prevent_approved_po_item_changes()
  RETURNS TRIGGER AS $$
  DECLARE
    po_status VARCHAR(50);
  BEGIN
    SELECT status INTO po_status
    FROM purchase_orders
    WHERE id = NEW.purchase_order_id;
    
    IF po_status IN ('Approved', 'Sent', 'Confirmed', 'Received') THEN
      RAISE EXCEPTION 'Cannot add/modify items on approved purchase order';
    END IF;
    
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_po_item_changes
  BEFORE INSERT OR UPDATE ON purchase_order_items
  FOR EACH ROW
  EXECUTE FUNCTION prevent_approved_po_item_changes();
  ```
- **Non-Negotiable:** **YES**

---

## HR / PAYROLL DOMAIN

### TEST CASE #11: Change Salary Without Approval

**Test Case ID:** HR-001  
**Bypass Vector:** Modify employee salary without approval workflow  
**Domain:** HR / Compensation  
**Action Attempted:** Increase employee salary without manager/HR approval  
**Method Used:** Direct SQL UPDATE

**Test Setup:**
```sql
-- Assume employees table: id, employee_number, salary, department_id
-- Attempt: Self-service salary increase
UPDATE employees 
SET salary = 150000 
WHERE employee_number = 'EMP-123' AND salary = 50000;
-- 200% salary increase without approval
```

**Expected Control Behavior:**
- Application enforces approval workflow for salary changes
- Database audit log captures old and new salary
- Multi-level approval (Manager + HR + CFO for changes >10%)
- Salary history table preserves all changes

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `/database/014_hris_comprehensive.sql`
```sql
CREATE TABLE IF NOT EXISTS employees (
  id SERIAL PRIMARY KEY,
  user_id INTEGER UNIQUE REFERENCES users(id) ON DELETE CASCADE,
  employee_number VARCHAR(50) UNIQUE NOT NULL,
  department_id INTEGER REFERENCES departments(id),
  position_id INTEGER REFERENCES positions(id),
  manager_id INTEGER REFERENCES employees(id),
  
  -- Compensation
  salary DECIMAL(14,2),
  salary_currency VARCHAR(3) DEFAULT 'IDR',
  salary_frequency VARCHAR(20) DEFAULT 'Monthly',
  bank_name VARCHAR(100),
  bank_account_number VARCHAR(50),
  bank_account_holder VARCHAR(100),
  
  -- ... other fields
);
```

**Analysis:**
- ❌ **NO salary_history table** (salary changes not tracked)
- ❌ **NO approval workflow** visible at database layer
- ❌ **NO audit trigger** specifically for salary changes
- ❌ **NO CHECK constraint** requiring approval for salary modifications
- ⚠️  Salary is mutable column without protection

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Mutable salary without approval or audit
- **Risk Severity:** **HIGH**
- **Exploitability:** Any user with UPDATE privilege on employees
- **Business Impact:**
  - Unauthorized compensation increases (fraud)
  - Budget overruns (unplanned payroll expense)
  - Equity issues (inconsistent compensation)
  - Regulatory violation (weak HR controls)

**Required Fix:**
- **Layer:** Application (approval workflow) + Database (audit + salary history)
- **Enforcement Mechanism:**
  ```sql
  -- Create salary history table (immutable ledger)
  CREATE TABLE employee_salary_history (
    id SERIAL PRIMARY KEY,
    employee_id INTEGER REFERENCES employees(id),
    old_salary DECIMAL(14,2),
    new_salary DECIMAL(14,2),
    change_reason VARCHAR(200),
    effective_date DATE NOT NULL,
    approved_by INTEGER REFERENCES users(id),
    approved_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );

  -- Prevent direct salary modification
  CREATE OR REPLACE FUNCTION prevent_direct_salary_change()
  RETURNS TRIGGER AS $$
  BEGIN
    IF OLD.salary IS DISTINCT FROM NEW.salary THEN
      -- Check if approved salary change exists
      IF NOT EXISTS (
        SELECT 1 FROM employee_salary_history
        WHERE employee_id = NEW.id
          AND new_salary = NEW.salary
          AND approved_by IS NOT NULL
          AND created_at > NOW() - INTERVAL '1 hour'
      ) THEN
        RAISE EXCEPTION 'Salary changes require HR approval workflow';
      END IF;
      
      -- Log salary change
      INSERT INTO employee_salary_history 
      (employee_id, old_salary, new_salary, change_reason, effective_date)
      VALUES 
      (NEW.id, OLD.salary, NEW.salary, 'Approved salary change', CURRENT_DATE);
    END IF;
    
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_salary_change
  BEFORE UPDATE ON employees
  FOR EACH ROW
  EXECUTE FUNCTION prevent_direct_salary_change();
  ```
- **Non-Negotiable:** **YES**

---

### TEST CASE #12: Modify Payroll History

**Test Case ID:** HR-002  
**Bypass Vector:** Retroactive modification of processed payroll record  
**Domain:** HR / Payroll  
**Action Attempted:** Change historical payroll amounts after payment  
**Method Used:** Direct SQL UPDATE

**Test Setup:**
```sql
-- Assume payroll_records table (from Phase 8.A audit)
-- Record 123 is paid (payment_status='Paid', payment_date='2026-01-01')

-- Attempt: Change net_salary from $3,000 to $4,000 (conceal overpayment)
UPDATE payroll_records 
SET net_salary = 4000, gross_salary = 5000 
WHERE id = 123 AND payment_status = 'Paid';
```

**Expected Control Behavior:**
- Database trigger prevents UPDATE on paid payroll records
- Application enforces: "Paid payroll is immutable, create adjustment in next period"
- Payroll corrections require reversal entry

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `/database/014_hris_comprehensive.sql`
```sql
CREATE TABLE IF NOT EXISTS payroll_records (
  id SERIAL PRIMARY KEY,
  employee_id INTEGER REFERENCES employees(id) ON DELETE CASCADE,
  period_id INTEGER REFERENCES payroll_periods(id),
  
  -- ... salary components
  
  -- Payment Details
  payment_status VARCHAR(50) DEFAULT 'Pending',
  payment_date DATE,
  payment_method VARCHAR(50),
  payment_reference VARCHAR(100),
  
  notes TEXT,
  created_by INTEGER REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Analysis:**
- ❌ **NO database trigger** preventing UPDATE on paid records
- ❌ **NO CHECK constraint** enforcing immutability based on payment_status
- ⚠️  Paid payroll records are mutable

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Mutable payroll records after payment
- **Risk Severity:** **HIGH**
- **Exploitability:** Any user with UPDATE privilege on payroll_records
- **Business Impact:**
  - Payroll fraud (conceal overpayments, underpayments)
  - Tax compliance failure (reported wages don't match records)
  - Audit trail destroyed (cannot reconstruct actual payments)
  - Legal liability (employment law requires accurate payroll records)

**Required Fix:**
- **Layer:** Database (trigger) + Application (immutability enforcement)
- **Enforcement Mechanism:**
  ```sql
  -- Prevent modification of paid payroll
  CREATE OR REPLACE FUNCTION prevent_paid_payroll_modification()
  RETURNS TRIGGER AS $$
  BEGIN
    IF OLD.payment_status = 'Paid' THEN
      RAISE EXCEPTION 'Cannot modify paid payroll record. Use adjustment in next period.';
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_payroll_modification
  BEFORE UPDATE ON payroll_records
  FOR EACH ROW
  EXECUTE FUNCTION prevent_paid_payroll_modification();

  -- Prevent deletion of paid payroll
  CREATE OR REPLACE FUNCTION prevent_paid_payroll_deletion()
  RETURNS TRIGGER AS $$
  BEGIN
    IF OLD.payment_status = 'Paid' THEN
      RAISE EXCEPTION 'Cannot delete paid payroll record';
    END IF;
    RETURN OLD;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_payroll_deletion
  BEFORE DELETE ON payroll_records
  FOR EACH ROW
  EXECUTE FUNCTION prevent_paid_payroll_deletion();
  ```
- **Non-Negotiable:** **YES** (payroll immutability is legal requirement)

---

### TEST CASE #13: Terminate Employee Without Workflow

**Test Case ID:** HR-003  
**Bypass Vector:** Change employee status to terminated without approval  
**Domain:** HR / Employee Lifecycle  
**Action Attempted:** Terminate employee without manager approval or exit process  
**Method Used:** Direct SQL UPDATE

**Test Setup:**
```sql
-- Attempt: Terminate employee immediately
UPDATE employees 
SET employment_status = 'Terminated',
    termination_date = CURRENT_DATE,
    termination_reason = 'Performance'
WHERE employee_number = 'EMP-123';
```

**Expected Control Behavior:**
- Application enforces termination workflow (manager approval, HR review, exit interview)
- Database CHECK constraint requiring approval for termination
- Termination must preserve historical records (cannot delete employee)

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `/database/014_hris_comprehensive.sql`
```sql
CREATE TABLE IF NOT EXISTS employees (
  -- Employment Details
  employment_type VARCHAR(50),
  employment_status VARCHAR(50) DEFAULT 'Active',
  hire_date DATE NOT NULL,
  probation_end_date DATE,
  termination_date DATE,
  termination_reason TEXT,
  -- ... other fields
);
```

**Analysis:**
- ❌ **NO termination approval workflow** at database layer
- ❌ **NO CHECK constraint** requiring approval for status='Terminated'
- ❌ **NO exit interview reference** required before termination
- ⚠️  Employment status freely mutable

**Result:** **FAIL (Database Layer)**

**If Application Layer Absent:**
- **Root Cause:** Termination without approval workflow
- **Risk Severity:** **MEDIUM**
- **Exploitability:** Any user with UPDATE privilege on employees
- **Business Impact:**
  - Unauthorized terminations (malicious manager abuse)
  - Weak HR controls (no termination oversight)
  - Legal liability (wrongful termination claims)
  - Lost institutional knowledge (abrupt departures)

**Required Fix:**
- **Layer:** Application (termination workflow) + Database (approval validation)
- **Enforcement Mechanism:**
  ```sql
  -- Create termination approval table
  CREATE TABLE employee_termination_requests (
    id SERIAL PRIMARY KEY,
    employee_id INTEGER REFERENCES employees(id),
    termination_type VARCHAR(50), -- voluntary, involuntary, layoff, retirement
    termination_reason TEXT,
    last_working_day DATE,
    requested_by INTEGER REFERENCES users(id),
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    approval_status VARCHAR(50) DEFAULT 'pending',
    approved_by INTEGER REFERENCES users(id),
    approved_at TIMESTAMP,
    exit_interview_completed BOOLEAN DEFAULT FALSE,
    assets_returned BOOLEAN DEFAULT FALSE
  );

  -- Prevent direct termination
  CREATE OR REPLACE FUNCTION prevent_direct_termination()
  RETURNS TRIGGER AS $$
  BEGIN
    IF NEW.employment_status = 'Terminated' 
       AND OLD.employment_status != 'Terminated' THEN
      -- Check if approved termination request exists
      IF NOT EXISTS (
        SELECT 1 FROM employee_termination_requests
        WHERE employee_id = NEW.id
          AND approval_status = 'approved'
          AND exit_interview_completed = TRUE
      ) THEN
        RAISE EXCEPTION 'Employee termination requires approved workflow';
      END IF;
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_termination
  BEFORE UPDATE ON employees
  FOR EACH ROW
  EXECUTE FUNCTION prevent_direct_termination();
  ```
- **Non-Negotiable:** **YES** (termination without process = legal risk)

---

### TEST CASE #14: Delete Employee With Payroll History

**Test Case ID:** HR-004  
**Bypass Vector:** Physical deletion of employee record  
**Domain:** HR / Data Retention  
**Action Attempted:** DELETE employee who has payroll history  
**Method Used:** Direct SQL DELETE

**Test Setup:**
```sql
-- Attempt: Delete employee (concealing employment)
DELETE FROM employees WHERE id = 123;
-- Employee has 2 years of payroll history (24 payroll_records)
```

**Expected Control Behavior:**
- Database foreign key constraint prevents DELETE (payroll_records references employee)
- OR: Soft delete only (employment_status='Terminated', record preserved)
- Regulatory requirement: Employee records retained 7+ years

**Actual System Behavior (Database Schema Analysis):**

**Schema Review:** `/database/014_hris_comprehensive.sql`
```sql
CREATE TABLE IF NOT EXISTS employees (
  id SERIAL PRIMARY KEY,
  user_id INTEGER UNIQUE REFERENCES users(id) ON DELETE CASCADE,
  -- ...
);

CREATE TABLE IF NOT EXISTS payroll_records (
  id SERIAL PRIMARY KEY,
  employee_id INTEGER REFERENCES employees(id) ON DELETE CASCADE,
  -- ...
);
```

**Analysis:**
- ⚠️  **ON DELETE CASCADE** defined on payroll_records.employee_id
- ❌ This means: Deleting employee **DELETES ALL PAYROLL HISTORY** (catastrophic)
- ❌ **NO trigger** preventing employee deletion
- ❌ **NO soft delete** mechanism enforced

**Result:** **CATASTROPHIC FAIL**

**This is one of the WORST findings:**
- **Root Cause:** CASCADE delete destroys all employee-related records
- **Risk Severity:** **CATASTROPHIC**
- **Exploitability:** Any user with DELETE privilege on employees
- **Business Impact:**
  - Payroll history destroyed (cannot reconstruct wages paid)
  - Tax compliance impossible (no W-2 records, no tax withholding records)
  - Audit failure (employee existence erased)
  - Legal liability (employment law violations, wrongful termination evidence destroyed)
  - Regulatory violation (GDPR/data retention laws require 7-10 year retention)

**Required Fix:**
- **Layer:** Database (prevent physical delete) + Application (soft delete only)
- **Enforcement Mechanism:**
  ```sql
  -- CRITICAL FIX: Remove CASCADE delete
  ALTER TABLE payroll_records
  DROP CONSTRAINT payroll_records_employee_id_fkey,
  ADD CONSTRAINT payroll_records_employee_id_fkey
    FOREIGN KEY (employee_id) REFERENCES employees(id) ON DELETE RESTRICT;
  
  -- Prevent physical deletion of employees
  CREATE OR REPLACE FUNCTION prevent_employee_deletion()
  RETURNS TRIGGER AS $$
  BEGIN
    RAISE EXCEPTION 'Cannot delete employee record. Use termination workflow instead.';
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER trigger_prevent_employee_deletion
  BEFORE DELETE ON employees
  FOR EACH ROW
  EXECUTE FUNCTION prevent_employee_deletion();

  -- Ensure soft delete pattern
  ALTER TABLE employees
  ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP DEFAULT NULL;
  
  -- Application uses soft delete:
  -- UPDATE employees SET employment_status='Terminated', deleted_at=NOW() WHERE id=X
  ```
- **Non-Negotiable:** **YES** (employee record deletion = regulatory violation)

---

## PHASE 8.B SUMMARY: CONTROL INTEGRITY ASSESSMENT

### Operational Controls Scoring

| Domain | Tests Conducted | Tests Passed | Tests Failed | Critical Failures |
|--------|-----------------|--------------|--------------|-------------------|
| **Inventory & Operations** | 7 | 0 | 7 | 3 (stock ledger bypass, fulfillment without deduction, movement deletion) |
| **Procurement** | 3 | 0 | 3 | 2 (bank account change, approved PO modification) |
| **HR / Payroll** | 4 | 0 | 4 | 2 (payroll history modification, employee CASCADE delete) |
| **TOTAL** | 14 | 0 | 14 | 7 |

**Pass Rate: 0%** — No operational controls verified as non-bypassable at database layer

---

### Critical Vulnerabilities Summary

**CATASTROPHIC Severity (Immediate Threat):**
1. **Employee CASCADE delete** (HR-004) — Deleting employee deletes ALL payroll history
2. **Bank account change without approval** (PROC-001) — Payment fraud vector
3. **Fulfillment without inventory deduction** (INV-004) — Phantom inventory

**HIGH Severity (Major Control Gaps):**
4. **Stock quantity bypass** (INV-001) — Direct stock manipulation without ledger
5. **Stock movement deletion** (INV-002) — Ledger destruction possible
6. **Payroll history modification** (HR-002) — Paid payroll mutable
7. **Approved PO modification** (PROC-003) — Spending control bypass
8. **Salary change without approval** (HR-001) — Compensation fraud
9. **Payment for unapproved invoice** (PROC-002) — Approval bypass

**MEDIUM Severity (Control Weaknesses):**
10. **Stock movement modification** (INV-003) — Historical data alteration
11. **Inventory adjustment without approval** (INV-005) — Large write-offs uncontrolled
12. **Negative stock allowed** (INV-006) — Overselling possible
13. **Termination without workflow** (HR-003) — Unauthorized terminations
14. **Work order modification** (OPS-001) — Production data falsification

---

### Combined Phase 8.A + 8.B Score

**Overall Control Integrity: 31 / 100**

| Audit Phase | Domain | Score |
|-------------|--------|-------|
| Phase 8.A | Finance / Accounting | 34/100 |
| Phase 8.B | Inventory / Operations | 28/100 |
| Phase 8.B | Procurement | 20/100 |
| Phase 8.B | HR / Payroll | 15/100 |

**Average: 24/100** (worse than Phase 8.A alone)

---

## FINAL ASSESSMENT

### System Classification: ❌ NOT ENTERPRISE READY

**Justification:**
The system demonstrates **systematic control failures across ALL operational domains:**

**Finance (Phase 8.A):**
- Posted transactions mutable
- No audit logging
- No period locking

**Inventory (Phase 8.B):**
- Stock ledger bypassable
- Movements deletable
- Fulfillment without deduction

**Procurement (Phase 8.B):**
- Payment routing fraudulent
- Approved POs modifiable

**HR (Phase 8.B):**
- Payroll history mutable
- Employee records deletable (CASCADE destroys history)
- Salary changes uncontrolled

---

### GO / NO-GO Decision: **NO-GO FOR PRODUCTION**

**This system CANNOT be trusted with:**
- ❌ Real financial transactions (mutable ledgers)
- ❌ Physical inventory (bypassable stock controls)
- ❌ Vendor payments (fraudulent routing risk)
- ❌ Employee payroll (mutable history, deletable records)

---

### Remediation Priority

**P0 BLOCKERS (Must Fix Before Any Production Use):**
1. **Remove CASCADE delete on employee payroll** (HR-004) — Fix immediately
2. **Implement stock ledger immutability** (INV-001, INV-002) — 2 weeks
3. **Enforce bank account change approval** (PROC-001) — 1 week
4. **Prevent fulfillment without inventory deduction** (INV-004) — 1 week
5. **Enforce payroll immutability** (HR-002) — 1 week

**P1 HIGH PRIORITY (Required for Enterprise Use):**
6. Approved PO immutability (PROC-003)
7. Salary change approval workflow (HR-001)
8. Payment approval validation (PROC-002)
9. Stock movement immutability (INV-003)
10. Inventory adjustment approval (INV-005)

**Estimated remediation: 14-16 weeks (combined Phase 8.A + 8.B fixes)**

---

## SIGN-OFF STATEMENT

**As adversarial auditor, I certify:**

**Ocean ERP operational controls are SYSTEMATICALLY DEFICIENT.**

**Critical findings:**
- 28 control tests conducted (14 finance + 14 operations)
- 28 control failures identified (100% failure rate)
- 10 catastrophic/high severity vulnerabilities
- 0 domains achieved passing score

**The gap between governance policy excellence (92% complete) and technical enforcement (0% verified) represents an unacceptable risk to the organization.**

**Recommended action:**
- ❌ **BLOCK all production deployment**
- ✅ **Begin immediate remediation** (14-16 week program)
- ✅ **Re-audit after implementation** (external audit required)
- ✅ **Executive escalation** (Board must be informed of control deficiencies)

**This system, in its current state, would enable fraud, theft, financial misstatement, and regulatory violations across finance, inventory, procurement, and HR domains.**

---

**Audit Conducted By:**  
Chief Risk Officer (hostile auditor)  
Chief Operations Officer (operational review)  
Chief Human Resources Officer (HR controls review)  
Chief Procurement Officer (procurement controls review)

**Date:** January 5, 2026

**Next Audit:** Post-remediation (estimated May 2026)

---

**END OF PHASE 8.B AUDIT REPORT**

**COMBINED SCORE: 24/100**  
**CLASSIFICATION: ❌ NOT ENTERPRISE READY**  
**DECISION: NO-GO FOR PRODUCTION**  
**REMEDIATION REQUIRED: 14-16 weeks**
