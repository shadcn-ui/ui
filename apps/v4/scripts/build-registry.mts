import { exec, execFile } from "child_process"
import { existsSync, promises as fs } from "fs"
import path from "path"
import { rimraf } from "rimraf"
import { registrySchema } from "shadcn/schema"
import { createStyleMap, transformStyle } from "shadcn/utils"

import { getAllBlocks } from "@/lib/blocks"
import { legacyStyles, type Style } from "@/registry/_legacy-styles"
import { BASES, type Base } from "@/registry/bases"
import { STYLES } from "@/registry/styles"

function getStylesToBuild() {
  const stylesToBuild: { name: string; title: string }[] = [...legacyStyles]

  for (const base of BASES) {
    for (const style of STYLES) {
      stylesToBuild.push({
        name: `${base.name}-${style.name}`,
        title: `${base.title} ${style.title}`,
      })
    }
  }

  return stylesToBuild
}

try {
  console.log("\nüóÇÔ∏è Building bases index...")
  await buildBasesIndex(Array.from(BASES))

  console.log("\nüèóÔ∏è Building bases...")
  await buildBases(Array.from(BASES))

  const stylesToBuild = getStylesToBuild()

  console.log(`\nüóÇÔ∏è Building registry/__index__.tsx...`)
  await buildRegistryIndex(stylesToBuild)
  console.log(`#Ô∏è‚É£  Built registry/__index__.tsx`)

  for (const style of stylesToBuild) {
    console.log(`\nüì¶ Processing style: ${style.name}`)

    console.log(`üíÖ Building registry-${style.name}.json...`)
    await buildRegistryJsonFile(style.name)

    console.log(`üèóÔ∏è Building registry for ${style.name}...`)
    await buildRegistry(style.name)
  }

  // console.log("\nüóÇÔ∏è Building registry/__blocks__.json...")
  // await buildBlocksIndex()

  // // Clean up intermediate files.
  // console.log("\nüßπ Cleaning up intermediate files...")
  // for (const style of styles) {
  //   if (existsSync(path.join(process.cwd(), `registry-${style.name}.json`))) {
  //     await fs.unlink(path.join(process.cwd(), `registry-${style.name}.json`))
  //   }
  // }

  console.log("\n‚úÖ Build complete!")
} catch (error) {
  console.error(error)
  process.exit(1)
}

async function buildBasesIndex(bases: Base[]) {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import "server-only"
import * as React from "react"

export const Index: Record<string, Record<string, any>> = {`

  for (const base of bases) {
    // Dynamically import the registry for this style.
    const { registry: importedRegistry } = await import(
      `../registry/bases/${base.name}/registry.ts`
    )

    // Validate the registry schema.
    const parseResult = registrySchema.safeParse(importedRegistry)
    if (!parseResult.success) {
      console.error(`‚ùå Registry validation failed for ${base.name}:`)
      console.error(parseResult.error.format())
      throw new Error(`Invalid registry schema for ${base.name}`)
    }

    const registry = parseResult.data

    index += `
  "${base.name}": {`

    for (const item of registry.items) {
      const files =
        item.files?.map((file) => ({
          path: typeof file === "string" ? file : file.path,
          type: typeof file === "string" ? item.type : file.type,
          target: typeof file === "string" ? undefined : file.target,
        })) ?? []

      if (files.length === 0) {
        continue
      }

      const componentPath = item.files?.[0]?.path
        ? `@/registry/bases/${base.name}/${item.files[0].path}`
        : ""

      index += `
    "${item.name}": {
      name: "${item.name}",
      title: "${item.title}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${files.map((file) => {
        const filePath = `registry/bases/${base.name}/${file.path}`
        return `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`
      })}],
      component: ${
        componentPath
          ? `React.lazy(async () => {
        const mod = await import("${componentPath}")
        const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || item.name
        return { default: mod.default || mod[exportName] }
      })`
          : "null"
      },
      categories: ${JSON.stringify(item.categories)},
      meta: ${JSON.stringify(item.meta)},
    },`
    }

    index += `
  },`
  }

  index += `
}`

  // Write unified index.
  rimraf.sync(path.join(process.cwd(), "registry/bases/__index__.tsx"))
  await fs.writeFile(
    path.join(process.cwd(), "registry/bases/__index__.tsx"),
    index
  )
}

async function buildBases(bases: Base[]) {
  for (const base of bases) {
    const { registry: baseRegistry } = await import(
      `../registry/bases/${base.name}/registry.ts`
    )

    // Validate the registry schema.
    const result = registrySchema.safeParse(baseRegistry)
    if (!result.success) {
      console.error(`‚ùå Registry validation failed for ${base.name}:`)
      console.error(result.error.format())
      throw new Error(`Invalid registry schema for ${base.name}`)
    }

    const registryItems = result.data.items.filter(
      (item) => item.type === "registry:ui"
    )

    for (const style of STYLES) {
      console.log(`\nüíÖ Building ${base.name}-${style.name}...`)

      const styleContent = await fs.readFile(
        path.join(process.cwd(), `registry/styles/style-${style.name}.css`),
        "utf8"
      )
      const styleMap = createStyleMap(styleContent)

      for (const registryItem of registryItems) {
        console.log(
          `üëâ Building ${base.name}-${style.name}-${registryItem.name}...`
        )

        // We're only parsing ui for now.
        // We can assume one file per registry item.
        const source = await fs.readFile(
          path.join(
            process.cwd(),
            `registry/bases/${base.name}/ui/${registryItem.name}.tsx`
          ),
          "utf8"
        )

        const transformedContent = await transformStyle(source, {
          styleMap: styleMap,
        })

        // Ensure the output directory exists before writing the file.
        const outputDir = path.join(
          process.cwd(),
          `registry/${base.name}-${style.name}/ui`
        )
        await fs.mkdir(outputDir, { recursive: true })
        await fs.writeFile(
          path.join(outputDir, `${registryItem.name}.tsx`),
          transformedContent
        )
      }
    }
  }
}

async function buildRegistryIndex(styles: { name: string; title: string }[]) {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, Record<string, any>> = {`

  for (const style of styles) {
    // Dynamically import the registry for this style.
    const { registry: importedRegistry } = await import(
      `../registry/${style.name}/registry.ts`
    )

    // Validate the registry schema.
    const parseResult = registrySchema.safeParse(importedRegistry)
    if (!parseResult.success) {
      console.error(`‚ùå Registry validation failed for ${style.name}:`)
      console.error(parseResult.error.format())
      throw new Error(`Invalid registry schema for ${style.name}`)
    }

    const registry = parseResult.data

    index += `
  "${style.name}": {`

    for (const item of registry.items) {
      const files =
        item.files?.map((file) => ({
          path: typeof file === "string" ? file : file.path,
          type: typeof file === "string" ? item.type : file.type,
          target: typeof file === "string" ? undefined : file.target,
        })) ?? []

      if (files.length === 0) {
        continue
      }

      const componentPath = item.files?.[0]?.path
        ? `@/registry/${style.name}/${item.files[0].path}`
        : ""

      index += `
    "${item.name}": {
      name: "${item.name}",
      title: "${item.title}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${files.map((file) => {
        const filePath = `registry/${style.name}/${file.path}`
        return `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`
      })}],
      component: ${
        componentPath
          ? `React.lazy(async () => {
        const mod = await import("${componentPath}")
        const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || item.name
        return { default: mod.default || mod[exportName] }
      })`
          : "null"
      },
      categories: ${JSON.stringify(item.categories)},
      meta: ${JSON.stringify(item.meta)},
    },`
    }

    index += `
  },`
  }

  index += `
}`

  // Write unified index.
  rimraf.sync(path.join(process.cwd(), "registry/__index__.tsx"))
  await fs.writeFile(path.join(process.cwd(), "registry/__index__.tsx"), index)
}

async function buildRegistryJsonFile(styleName: string) {
  // 1. Import the registry for this style.
  const { registry: importedRegistry } = await import(
    `../registry/${styleName}/registry.ts`
  )

  // 2. Validate the registry schema.
  const parseResult = registrySchema.safeParse(importedRegistry)
  if (!parseResult.success) {
    console.error(`‚ùå Registry validation failed for ${styleName}:`)
    console.error(parseResult.error.format())
    throw new Error(`Invalid registry schema for ${styleName}`)
  }

  const registry = parseResult.data

  // 3. Fix the path for registry items.
  const fixedRegistry = {
    ...registry,
    items: registry.items.map((item) => {
      const files = item.files?.map((file) => {
        return {
          ...file,
          path: `registry/${styleName}/${file.path}`,
        }
      })

      return {
        ...item,
        files,
      }
    }),
  }

  // 3. Create the output directory and write registry.json.
  const outputDir = path.join(process.cwd(), `public/r/styles/${styleName}`)
  await fs.mkdir(outputDir, { recursive: true })

  // 4. Write registry.json to output directory and format it.
  const registryJsonPath = path.join(outputDir, "registry.json")
  await fs.writeFile(registryJsonPath, JSON.stringify(fixedRegistry, null, 2))
  await new Promise<void>((resolve, reject) => {
    execFile("prettier", ["--write", registryJsonPath], (error) => {
      if (error) {
        reject(error)
      } else {
        resolve()
      }
    })
  })

  // 5. Write temporary registry file needed by shadcn build.
  const tempRegistryPath = path.join(
    process.cwd(),
    `registry-${styleName}.json`
  )
  await fs.writeFile(tempRegistryPath, JSON.stringify(fixedRegistry, null, 2))
}

async function buildRegistry(styleName: string) {
  return new Promise((resolve, reject) => {
    // Use local shadcn copy.
    const outputPath = `public/r/styles/${styleName}`
    const process = exec(
      `node ../../packages/shadcn/dist/index.js build registry-${styleName}.json --output ${outputPath}`
    )

    // exec(
    //   `pnpm dlx shadcn build registry-${styleName}.json --output public/r/styles/${styleName}`
    // )

    process.on("exit", (code) => {
      if (code === 0) {
        resolve(undefined)
      } else {
        reject(new Error(`Process exited with code ${code}`))
      }
    })
  })
}

async function buildBlocksIndex() {
  const blocks = await getAllBlocks(["registry:block"])

  const payload = blocks.map((block) => ({
    name: block.name,
    description: block.description,
    categories: block.categories,
  }))

  rimraf.sync(path.join(process.cwd(), "registry/__blocks__.json"))
  await fs.writeFile(
    path.join(process.cwd(), "registry/__blocks__.json"),
    JSON.stringify(payload, null, 2)
  )

  await exec(`prettier --write registry/__blocks__.json`)
}
